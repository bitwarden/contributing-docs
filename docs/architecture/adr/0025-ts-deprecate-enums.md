---
adr: "0025"
status: Proposed
date: 2025-05-30
tags: [clients, typescript]
---

# 0025 - Deprecate TypeScript Enum Types

<AdrTable frontMatter={frontMatter}></AdrTable>

## Context and Problem Statement

TypeScript experts have long discouraged the use of enums. There are a variety of cited reasons.
Among them:

- Enums that are not `const` substantially increase output size.
- Numeric enums implicitly cast from `number` to the enum type, which allows invalid enum values to
  be transmitted to functions.
- String enums are named types that require a member is used, which is inconsistent with the
  behavior of numeric enums.

These inconsistencies cause increased complexity from guard statements in the best of cases. In the
worst cases, their limitations may be unknown, and thus unguarded.

### Detection

TypeScript deprecation can be linted using a fairly short ESLint plugin. The code has [already been
contributed to main][no-enum-lint] as a suggestion. The same PR adds `FIXME` comments for each team
to address.

### Replacement pattern

In most cases, enums are unnecessary. A readonly (`as const`) object coupled with a type alias
avoids both code generation and type inconsistencies.

```ts
// declare the raw data and reduce repetition with an inner type
const _CipherType = {
  Login: 1,
  SecureNote: 2,
  Card: 3,
  Identity: 4,
  SshKey: 5,
} as const;

type _CipherType = typeof _CipherType;

// derive the enum-like type from the raw data
export type CipherType = _CipherType[keyof _CipherType];

// assert that the raw data is of the enum-like type
export const CipherType: Readonly<{ [K in keyof typeof _CipherType]: CipherType }> =
  Object.freeze(_CipherType);
```

This code creates a type `CipherType` that allows arguments and variables to be typed similarly to
an enum. It also strongly types the `CiperType` constant so that direct accesses of its members
preserve type safety. No type assertions are needed to work directly with `CipherType`.

This pattern has two negative consequences. First, mapped types cannot determine that a mapped type
is fully specified. Code like the following causes a compiler error:

```ts
type MappedType = { [K in CipherType]: boolean };

const instance: MappedType = {
  [CipherType.Login]: true,
  [CipherType.SecureNote]: true,
  [CipherType.Card]: true,
  [CipherType.Identity]: true,
  [CipherType.SshKey]: true,
};
```

This happens because each enum members' literal type is overridden by `CipherType`. The compiler
cannot determine that every kind of `CipherType` is listed. There are a few workarounds:

```ts
// option A: use a type assertion to construct the mapped type
const instance: MappedType = {
  [CipherType.Login]: true,
  // ...
} as MappedType;

// option B: make the type partial and it fully typechecks, but you
//   need to inspect its properties to use them.
type PartialMappedType = { [K in CipherType]?: boolean };
const instance = {
  [CipherType.Login]: true,
  // ...
};
if (instance[CipherType.Login]) {
  // work with `instance`
}
```

The other problem is that mapped types cannot specify the enum-like's members as field names. Code
like the following causes a compiler error:

```ts
type SomeType = { [CipherType.SecureNote]: boolean };
```

[This issue is fixed as of TypeScript 5.8](no-member-fields-fixed).

## Considered Options

- **Allow enums, but advise against them** - This is the current state of affairs. With this option,
  teams **must** address the FIXMEs, but _may_ address them by disabling the lint.
- **Deprecate enum use** - Allow enums to exist for historic purposes, but prohibit the introduction
  of new ones. Increase the lint to a "warning" and allow the lint to be disabled.
- **Eliminate enum use** - Prohibit the introduction of any new enum and replace all enums in the
  codebase with typescript objects. Increase the lint to an "error" and prohibit disabling of the
  lint.

## Decision Outcome

Chosen option: **Deprecate enum use**

### Positive Consequences

- Allows for cases where autogenerated code introduces an enum by necessity.
- Developers receive a warning in their IDE to discourage new enums.
- The warning can direct them to our contributing docs, where they can learn typesafe alternatives.
- Over time, our code size decreases as enums are replaced.
- If all teams eliminate enums in practice, the warning can be increased to an error.

### Negative Consequences

- Unnecessary usage may persist indefinitely on teams carrying a high tech debt.
- The lint increases the number of FIXME comments in the code by about 10%.

### Plan

- Update contributing docs with patterns and best practices for enum replacement.
- Update the reporting level of the lint to "warning".

[no-enum-lint]: https://github.com/bitwarden/clients/blob/main/libs/eslint/platform/no-enums.mjs
[no-member-fields-fixed]:
  https://devblogs.microsoft.com/typescript/announcing-typescript-5-8-beta/#preserved-computed-property-names-in-declaration-files
