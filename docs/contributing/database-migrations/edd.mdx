import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Evolutionary Database Design

At Bitwarden we follow
[Evolutionary Database Design (EDD)](https://en.wikipedia.org/wiki/Evolutionary_database_design).
EDD describes a process where the database schema is continuously updated while still ensuring
compatibility with older releases by using database transition phases.

In short the Database Schema for the Bitwarden Server **must** support the previous release of the
server at any given time.

<bitwarden>

:::note

For background on this decision please see the [Evolutionary Database Design RFD][edd-rfd].

:::

</bitwarden>

## Design

Martin Fowler's EDD defines two types of database changes: destructive and non-destructive
([EDD -Transition Phase: All database changes are database refactors](https://www.martinfowler.com/articles/evodb.html#TransitionPhase)).
A destructive change is any database change that requires an accompanying code change to continue
working as expected. A non-destructive change is the opposite: a database change that does not
require a code change to allow the application to continue working as expected.

### Non-destructive Database Changes

An example of a non-destructive change is almost always using either nullable fields or default
values in database tables, views, and stored procedures. We have adopted this as a standard for any
such changes. This will allow stored procedures to omit columns, which is a requirement when running
both old and new code.

### Destructive Changes

In our current release process where our database changes and our code changes are coupled, even a
new column can even be considered a destructive change if the default value of the column is a
non-constant value that needs to be computed from elsewhere.

Martin Fowler's explanation of how to elegantly handle destructive database changes in an EDD way
breaks up such a change into three phases: _Start_, _Transition_ and _End_.

![Refactoring Stages](./stages_refactoring.jpg)
[https://www.martinfowler.com/articles/evodb.html#TransitionPhase](https://www.martinfowler.com/articles/evodb.html#TransitionPhase)

We tweak the terminology to be more easily understandable in how EDD relates to our deployment
processes in both our environments: our always-on application in the cloud and our self-host
deployments. We use the terms: _Initial_ Phase (instead of _Start_), _Transition_ Phase, and
_Finalization_ Phase (instead of _End_).

#### Initial Phase

- <u>
    Compatible with <i>previous</i> <b>and</b> <i>next</i> application code changes
  </u>
- Represents the beginning of a database change
- Updates our database schema to support any new functionality while also maintaining old
  functionality
- Supports both the previous version of code and the one being upgraded to
- Run during upgrade
- Must execute quickly to minimize downtime.

#### Transition Phase

- <u>
    Compatible with <i>previous</i> <b>and</b> <i>next</i> application code changes
  </u>
- The time between initial migration and finalization
- Exists to provide an opportunity to rollback server to _previous_ version prior to breaking
  changes
- Only data population migrations may be run at this time, if they are needed
  - Optional step, required only when migrating data would be too slow to execute during the initial
    migration. This might be a column population, index creation, anything to prepare our database
    for the _next_ version
  - Must be run as a background task during our Transition phase.
  - These MUST run in a way where the database stays responsive during the full migration
- Schema changes are NOT to be run during this phase.

#### Finalization Phase

- <u>
    Only compatible with <i>next</i> application code; represents the point of no return for this
    migration
  </u>
- Removes columns, data, and fallback code required to support _previous_ version
- Should be run as a typical migration either during a subsequent upgrade

### Example

Let’s look at an example, the rename column refactor is shown in the image below.

![Rename Column Refactor](./rename-column.gif)

In this refactor we rename the column `Fname` in the `Customer` table to `FirstName`. This could
easily be achieved using a regular `Alter Table` statement but that would break compatibility with
existing running code. Instead let's look at how we can incrementally refactor this table.

We will begin by creating a migration which adds the column `FirstName` to the `Customer` Table. At
the same time we will also update the Stored Procedures to sync the content between `FName` and
`FirstName` which ensures both the old and new server releases can run at the same time. The sync
code is highlighted in the code snippet below.

Afterwards the new server version will be deployed, once everything checks out the existing data
will be migrated using a _Data Migration_ script. Which essentially copies the `FName` to
`FirstName` columns.

Lastly the _Second Migration_ will be run which removes the old column and updates the Stored
Procedure to remove the synchronization logic.

#### Migrations

:::note

All database migrations should support being run multiple times; even if subsequent runs perform no
actions.

:::

<Tabs>
<TabItem value="first" label="Initial Migration" default>

```sql
-- Add Column
IF COL_LENGTH('[dbo].[Customer]', 'FirstName') IS NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    ADD
        [FirstName] NVARCHAR(MAX) NULL
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FName NVARCHAR(MAX) = NULL, -- Deprecated as of YYYY-MM-DD
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    SET @FirstName = COALESCE(@FirstName, @FName);

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FName],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName,
        @FirstName
    )
END
```

</TabItem>
<TabItem value="data" label="Transition Migration">

```sql
UPDATE [dbo].Customer SET
    FirstName=FName
WHERE FirstName IS NULL
```

</TabItem>
<TabItem value="second" label="Finalization Migration">

```sql
-- Remove Column
IF COL_LENGTH('[dbo].[Customer]', 'FName') IS NOT NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    DROP COLUMN
        [FName]
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName
    )
END
```

</TabItem>
</Tabs>

## Our EDD Process

There are some unique constraints to Bitwarden that are not addressed directly in Martin Fowler's
EDD article.

- Our Production instances in the cloud are required to be on at all times
- Our self-host instances that we do not directly have access to manage must support the same EDD
  processes; however, they do not have the same always-on application constraint
- Minimization of manual steps in our process

The process to support all of these constraints is a complex one. Below is an image of a state
machine that will hopefully help visualize the process and what it supports. It assumes that all
database changes follow the standards that are laid out in [Migrations](./).

---

![Bitwarden EDD State Machine](./EDD-State-Machine.jpg) \[Open Image in a new tab for better
viewing\]

---

### Cloud Environments

Since we treat both schema migrations and data migrations as just migrations, the only issues that
we are solving for is orchestrating the runtime constraints on the migration. Eventually, all
migrations will end up in `DbScripts`. However, to control the timing of running _Transition_ and
associated _Finalization_ migrations, we need to keep them outside of `DbScripts` until the correct
timing.

In our environments with always-on applications, _Transition_ scripts must be run after the new code
has been rolled out. To execute a full deploy, we run all new migrations in `DbScripts`, roll out
the new code, and then run all _Transition_ migrations in the `DbScripts_transition` directory as
soon as all of the new code services are online. In the case of a critical failure after the new
code is rolled out, we will conduct a Rollback (see Rollbacks below). _Finalization_ migrations will
not be run until the start of the next deploy when they are moved into `DbScripts`.

After this deploy, to prep for the next release, all migrations in `DbScripts_transition` are moved
to `DbScripts` and then all migrations in `DbScripts_finalization` are moved to `DbScripts`,
conserving their execution order for a clean install. For our current branching strategy, PRs will
be open against `master` when `rc` is cut to prep for this release. This PR automation will also
handle renaming the migration file and updating any reference of `[dbo_future]` to `[dbo]`.

The next deploy will pick up the newly added migrations in `DbScripts` and set the previously
rerunnable _Transition_ migrations to no longer be rerunnable, execute the _Finalization_
migrations, and then execute any new migrations associated with the code changes that are about to
go out.

The the state of migrations in the different directories at any one time is is saved and versioned
in our Migrator Utility which supports the EDD phased migration process in both types of
environments.

### Standard Self-host Environments

We need to have a similarly orchestrated process as Cloud environments here. However, we are not
constrained to having an always-on application. Our updated orchestration process for self-host will
be:

- Stop the Bitwarden stack as we do today
- Start the database
- Run all new migrations in `DbScripts` (both _Finalization_ migrations from the last deploy and any
  _Initial_ migrations from the deploy currently going out)
- Run all _Transition_ migrations
- Restart the Bitwarden stack.

## Rollbacks

In the event the server release failed and needs to be rolled back, it should be as simple as just
re-deploying the previous version again. The database will **stay** in the transition phase until a
hotfix can be released, and the server can be updated. Once a hotfix is ready to go out, we deploy
that hotfix and rerun the _Transition_ migrations to verify that the DB is in the state that it is
required to be in.

Should a feature need to be completely pulled, a new migration needs to be written to undo the
database changes and the future migration will also need to be updated to work with the database
changes. This is generally not recommended since pending migrations (for other releases) will need
to be revisited.

## Testing

Prior to merging a PR please ensure that the database changes run well on the currently released
version. We currently do not have an automated test suite for this and it’s up to the developers to
ensure their database changes run correctly against the currently released version.

## Further Reading

- [Evolutionary Database Design](https://martinfowler.com/articles/evodb.html) (Particularly
  [All database changes are database refactorings](https://martinfowler.com/articles/evodb.html#AllDatabaseChangesAreMigrations))
- [The Agile Data (AD) Method](http://agiledata.org/) (Particularly
  [Catalog of Database Refactorings](http://agiledata.org/essays/databaseRefactoringCatalog.html))
- [Refactoring Databases: Evolutionary Database](https://databaserefactoring.com/)
- Refactoring Databases: Evolutionary Database Design (Addison-Wesley Signature Series (Fowler))
  ISBN-10: 0321774515

[edd-rfd]:
  https://bitwarden.atlassian.net/wiki/spaces/PIQ/pages/177701412/Adopt+Evolutionary+database+design
