import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import refactoringPhases from "./stages_refactoring.jpg";
import eddStateMachine from "./edd_state_machine.jpg";

# Evolutionary database design

At Bitwarden we follow
[Evolutionary Database Design (EDD)](https://en.wikipedia.org/wiki/Evolutionary_database_design).
EDD describes a process where the database schema is continuously updated while still ensuring
compatibility with older releases by using database transition phases.

In short the Database Schema for the Bitwarden Server **must** support the previous release of the
server at any given time.

<bitwarden>

:::note

For background on this decision please see the [Evolutionary Database Design RFD][edd-rfd].

:::

</bitwarden>

## Design

Two types of database changes exist: destructive and non-destructive \[[1](./edd#further-reading)\].
A destructive change is any database change that requires an accompanying code change to continue
working as expected. A non-destructive change is the opposite: a database change that does not
require a code change to allow the application to continue working as expected.

### Non-destructive database changes

An example of a non-destructive change is almost always using either nullable fields or default
values in database tables, views, and stored procedures. This as a standard for any such changes.
This will allow stored procedures to omit columns, which is a requirement when running both old and
new code.

### Destructive changes

The current release process couples database and code changes, even a new column can even be
considered a destructive change if the default value of the column is a non-constant value that
needs to be computed from elsewhere.

Destructive database changes are handled elegantly by breaking them up into three phases: _Start_,
_Transition_ and _End_.

<div style={{ margin: "1em" }}>
  <img src={refactoringPhases} alt="Refactoring Phases" />
  <div style={{ fontSize: 12, textAlign: "center" }}>
    Refactoring Phases [<a href="./edd#further-reading">1</a>]
  </div>
</div>

The terminology is tweaked to be more easily understandable in relation to two types of deployment
processes: always-on environments and offline update environments. The terms: _Initial_ Phase
(instead of _Start_), _Transition_ Phase, and _Finalization_ Phase (instead of _End_).

#### Initial phase

- Compatible with _X.1.0_ **and** _X.2.0_ application code changes
- Represents the beginning of a database change
- Updates the database schema to support any new functionality while also maintaining old
  functionality
- Supports both the previous version of code and the one being upgraded to
- Run during upgrade
- Must execute quickly to minimize downtime.

#### Transition phase

- Compatible with _X.1.0_ **and** _X.2.0_ application code changes
- The time between initial migration and finalization
- Exists to provide an opportunity to rollback server to _X.1.0_ version prior to breaking changes
- Only data population migrations may be run at this time, if they are needed
  - Optional step, required only when migrating data would be too slow to execute during the initial
    migration. This might be a column population, index creation, anything to prepare the database
    for the _X.2.0_ version
  - Must be run as a background task during the Transition phase.
  - These MUST run in a way where the database stays responsive during the full migration
- Schema changes are NOT to be run during this phase.

#### Finalization phase

- Only compatible with _X.2.0_ application code; represents the point of no return for this
  migration
- Removes columns, data, and fallback code required to support _X.1.0_ version
- Should be run as a typical migration either during a subsequent upgrade

### Example

Let’s look at an example, the rename column refactor is shown in the image below.

![Rename Column Refactor](./rename-column.gif)

In this refactor we rename the column `Fname` in the `Customer` table to `FirstName`. This could
easily be achieved using a regular `Alter Table` statement but that would break compatibility with
existing running code. Instead let's look at how we can incrementally refactor this table.

We will begin by creating a migration which adds the column `FirstName` to the `Customer` Table. At
the same time we will also update the Stored Procedures to sync the content between `FName` and
`FirstName` which ensures both the old and new server releases can run at the same time. The sync
code is highlighted in the code snippet below.

Afterwards the new server version will be deployed, once everything checks out the existing data
will be migrated using a _Data Migration_ script. Which essentially copies the `FName` to
`FirstName` columns.

Lastly the _Second Migration_ will be run which removes the old column and updates the Stored
Procedure to remove the synchronization logic.

#### Migrations

:::note

All database migrations should support being run multiple times; even if subsequent runs perform no
actions.

:::

<Tabs>
<TabItem value="first" label="Initial Migration" default>

```sql
-- Add Column
IF COL_LENGTH('[dbo].[Customer]', 'FirstName') IS NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    ADD
        [FirstName] NVARCHAR(MAX) NULL
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FName NVARCHAR(MAX) = NULL, -- Deprecated as of YYYY-MM-DD
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    SET @FirstName = COALESCE(@FirstName, @FName);

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FName],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName,
        @FirstName
    )
END
```

</TabItem>
<TabItem value="data" label="Transition Migration">

```sql
UPDATE [dbo].Customer SET
    FirstName=FName
WHERE FirstName IS NULL
```

</TabItem>
<TabItem value="second" label="Finalization Migration">

```sql
-- Remove Column
IF COL_LENGTH('[dbo].[Customer]', 'FName') IS NOT NULL
BEGIN
    ALTER TABLE
        [dbo].[Customer]
    DROP COLUMN
        [FName]
END
GO

-- Drop existing SPROC
IF OBJECT_ID('[dbo].[Customer_Create]') IS NOT NULL
BEGIN
    DROP PROCEDURE [dbo].[Customer_Create]
END
GO

-- Create the new SPROC
CREATE PROCEDURE [dbo].[Customer_Create]
    @CustomerId UNIQUEIDENTIFIER OUTPUT,
    @FirstName NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON

    INSERT INTO [dbo].[Customer]
    (
        [CustomerId],
        [FirstName]
    )
    VALUES
    (
        @CustomerId,
        @FirstName
    )
END
```

</TabItem>
</Tabs>

## Bitwarden EDD process

There are some unique constraints to how Bitwarden has to implement this process.

- Bitwarden Production environments are required to be on at all times
- Self-host instances must support the same database change process; however, they do not have the
  same always-on application constraint
- Minimization of manual steps in the process

The process to support all of these constraints is a complex one. Below is an image of a state
machine that will hopefully help visualize the process and what it supports. It assumes that all
database changes follow the standards that are laid out in [Migrations](./).

---

![Bitwarden EDD State Machine](./edd_state_machine.jpg) \[Open Image in a new tab for better
viewing\]

---

### Online environments

Schema migrations and data migrations as just migrations. The underlying implementation issue is
orchestrating the runtime constraints on the migration. Eventually, all migrations will end up in
`DbScripts`. However, to orchestrate the running of _Transition_ and associated _Finalization_
migrations, they are kept outside of `DbScripts` until the correct timing.

In environments with always-on applications, _Transition_ scripts must be run after the new code has
been rolled out. To execute a full deploy, all new migrations in `DbScripts` are run, the new code
is rolled out, and then all _Transition_ migrations in the `DbScripts_transition` directory are run
as soon as all of the new code services are online. In the case of a critical failure after the new
code is rolled out, a Rollback would be conducted (see Rollbacks below). _Finalization_ migrations
will not be run until the start of the next deploy when they are moved into `DbScripts`.

After this deploy, to prep for the next release, all migrations in `DbScripts_transition` are moved
to `DbScripts` and then all migrations in `DbScripts_finalization` are moved to `DbScripts`,
conserving their execution order for a clean install. For the current branching strategy, PRs will
be open against `master` when `rc` is cut to prep for this release. This PR automation will also
handle renaming the migration file and updating any reference of `[dbo_finalization]` to `[dbo]`.

The next deploy will pick up the newly added migrations in `DbScripts` and set the previously
repeatable _Transition_ migrations to no longer be repeatable, execute the _Finalization_
migrations, and then execute any new migrations associated with the code changes that are about to
go out.

The the state of migrations in the different directories at any one time is is saved and versioned
in the Migrator Utility which supports the phased migration process in both types of environments.

### Offline environments

The process for offline environments is similar to the always-on ones. However, since they do not
have the constraint of always being on, the _Initial_ and _Transition_ migrations will be run one
after the other:

- Stop the Bitwarden stack as done today
- Start the database
- Run all new migrations in `DbScripts` (both _Finalization_ migrations from the last deploy and any
  _Initial_ migrations from the deploy currently going out)
- Run all _Transition_ migrations
- Restart the Bitwarden stack.

## Rollbacks

In the event the server release failed and needs to be rolled back, it should be as simple as just
re-deploying the previous version again. The database will **stay** in the transition phase until a
hotfix can be released, and the server can be updated. Once a hotfix is ready to go out, it is
deployed the _Transition_ migrations are rerun to verify that the DB is in the state that it is
required to be in.

Should a feature need to be completely pulled, a new migration needs to be written to undo the
database changes and the future migration will also need to be updated to work with the database
changes. This is generally not recommended since pending migrations (for other releases) will need
to be revisited.

## Testing

Prior to merging a PR please ensure that the database changes run well on the currently released
version. We currently do not have an automated test suite for this and it’s up to the developers to
ensure their database changes run correctly against the currently released version.

## Further reading

1. [Evolutionary Database Design](https://martinfowler.com/articles/evodb.html) (Particularly
   [All database changes are database refactorings](https://martinfowler.com/articles/evodb.html#AllDatabaseChangesAreMigrations))
2. [The Agile Data (AD) Method](http://agiledata.org/) (Particularly
   [Catalog of Database Refactorings](http://agiledata.org/essays/databaseRefactoringCatalog.html))
3. [Refactoring Databases: Evolutionary Database](https://databaserefactoring.com/)
4. Refactoring Databases: Evolutionary Database Design (Addison-Wesley Signature Series (Fowler))
   ISBN-10: 0321774515

[edd-rfd]:
  https://bitwarden.atlassian.net/wiki/spaces/PIQ/pages/177701412/Adopt+Evolutionary+database+design
